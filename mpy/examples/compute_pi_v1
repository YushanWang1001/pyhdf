#!/usr/bin/env python

# This code is adapted from:
#   "Using MPI. Portable Parallel Programming with the Message-Passing Interface."
#   2nd Ed. Gropp, W., Lusk. E and A. Skjellum.
#   Figure 3.3, p 30.

# This example implements the classical computation of PI
# done by integrating function f(x)=1/(1+x*x) over interval [0,1],
# delegating to each process the computation of the area of 1 every
# n rectangle under the curve.

import sys, math
import Numeric

from mpy import *

MPY_Init(sys.argv)   
myid =    MPY_Comm_rank()
numproc = MPY_Comm_size()
node =    MPY_Get_processor_name()
root = 0

print "I am P%d of %d on node %s" % (myid, numproc, node)
MPY_Barrier()

def f(x):
    return 4.0 / (1.0 + x * x)

# Get number of steps.
if myid == 0:
    if len(sys.argv) != 2:
        print "Usage: compute_pi n"
	sys.exit(1)
    n = int(sys.argv[1])
# Undefined for non-root processes.
else:
    n = None

# Broadcast the number of steps 'n' to all processes.
# It the current process is the root process, 'n' has just been read
# from the command line. Otherwise, 'n' is None ans is ignored.
n = MPY_Bcast(root, n)

# Integrate.
t0 = MPY_Wtime()
h = 1.0 / n
sum = 0.0
for i in range(myid + 1, n + 1, numproc):
    x = h * (i - 0.5)
    y = f(x)
    sum += y

# Send the partial sum to root process.
res = MPY_Reduce(sum, MPY_SUM, root)

# Display time statistics.
print "P%d took %f secs" % \
      (myid, MPY_Wtime() - t0)
MPY_Barrier()
if myid == 0:
    mypi = h * res
    print "PI is about", mypi, "error=", abs(math.pi - mypi)

MPY_Finalize()
