#!/usr/bin/env python

# This code is adapted from:
#   "Using MPI. Portable Parallel Programming with the Message-Passing Interface."
#   2nd Ed. Gropp, W., Lusk. E and A. Skjellum.
#   pp 48-51.

import sys, math, time
import Numeric
from mpy import *

cols = 4
rows = 4
OVERTAG = 32000

def master(masterId):

    t0 = MPY_Wtime()
    # Initialize matrices 'a' and 'b'
    a = Numeric.zeros((rows, cols), 'f')
    b = Numeric.identity(rows, 'f') * Numeric.array(2.0, 'f')
    for j in range(cols):
        for i in range(rows):
            a[i,j] = i+j
    
    # Send matrix b to each slave process.
    MPY_Bcast(masterId, b, dataType=MPY_PYTHON_ARRAY)
    
    # Seed each slave process with a row, tagging with row number.
    r = 0
    for p in range(MPY_Comm_size()):
        # Do not send to master
        if p == masterId:
            continue
        # Send row 'r' using row number as tag.
	MPY_Send(a[r], p, dataType=MPY_PYTHON_ARRAY, tag=r)
	r += 1
        if r == rows:
            break

    # Collect products.
    res = Numeric.zeros((rows, cols), 'f')
    ans = Numeric.zeros(cols, 'f')
    numsent = r
    for r in range(rows):
        # Read a product from any slave, for any row.
        # The tag identifies the row number.
        ans, status = MPY_Recv(MPY_ANY_SOURCE, dataType=MPY_PYTHON_ARRAY, array=ans,
                               tag=MPY_ANY_TAG, retStatus=True)
        source = status.source
        rowNum = status.tag
        res[rowNum] = ans
        if numsent < rows:
            # Send another row to the slave who just answered.
            MPY_Send(a[numsent], source, dataType=MPY_PYTHON_ARRAY, tag=numsent)
            numsent += 1
        else:
            # Signal end of processing with an OVERTAG tag.
            MPY_Send(0, source, tag=OVERTAG)

    print "time=",MPY_Wtime() - t0
    print "a=\n", a
    print "b=\n", b
    print "a*b=\n", res


def slave(masterId, slaveId):

    # Initialize matrix 'b' and row vector 'r'.
    b = Numeric.zeros((rows, cols), 'f')
    r = Numeric.zeros(cols, 'f')
    prod = Numeric.zeros(cols, 'f')

    # Receive value of 'b' from master.
    MPY_Bcast(masterId, dataType=MPY_PYTHON_ARRAY, array=b)

    while True:
        # Receive row from master.
        r, status = MPY_Recv(masterId, dataType=MPY_PYTHON_ARRAY, array=r,
                             tag=MPY_ANY_TAG, retStatus=True)
        rowNum = status.tag
        source = status.source

        if rowNum == OVERTAG:
            break

        # Compute vector product.
        for j in range(cols):
            dot = 0.0
            for i in range(rows):
                dot += r[i] * b[i,j]
            prod[j] = dot

        # Send products to master. Tag identifies the row number.
        MPY_Send(prod, masterId, dataType=MPY_PYTHON_ARRAY, tag=rowNum)
    
        
MPY_Init()
rank =    MPY_Comm_rank()
numproc = MPY_Comm_size()
node =    MPY_Get_processor_name()
root = 0

print "P%d of %d running on node %s" %(rank, numproc, node)
MPY_Barrier()

if rank == root:
    master(rank)
else:
    slave(root, rank)

MPY_Finalize()
