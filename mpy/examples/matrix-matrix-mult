#!/usr/bin/env python

# Matrix-matrix multiplication. Adapted from :
# "Using MPI, 2nd ed.", pp 48-51.

import sys, math, time
import Numeric
import mpi


cols = 50
rows = 50
OVERTAG = 32000

def master(masterId):

    t0 = mpi.wtime()
    # Initialize matrices 'a' and 'b'
    a = Numeric.zeros((rows, cols), 'f')
    b = Numeric.zeros((rows, cols), 'f')
    for j in range(cols):
        b[j,j] = 1.0              # Identity
        for i in range(rows):
            a[i,j] = i
    
    # Send matrix b to each slave process.
    mpi.bcast(b, masterId)
    
    # Seed each slave process with a row, tagging with row number.
    r = 0
    for p in range(mpi.comm_size()):
        # Do not send to master
        if p == masterId:
            continue
        # Send row 'r' using row number as tag.
	mpi.send(a[r], p, tag=r)
	r += 1
        if r == rows:
            break

    # Collect products.
    res = Numeric.zeros((rows, cols), 'f')
    ans = Numeric.zeros(cols, 'f')
    numsent = r
    gotFrom = [0] * mpi.comm_size()
    for r in range(rows):
        # Read a product from any slave, for any row.
        # The tag identifies the row number.
        ans, status = mpi.recv(mpi.MPI_ANY_SOURCE,
                               tag=mpi.MPI_ANY_TAG,
                               retStatus=True)
        source = status.source
        rowNum = status.tag
        res[rowNum] = ans
        gotFrom[source] = gotFrom[source] + 1   # number of rows computed there
        if numsent < rows:
            # Send another row to the slave who just answered.
            mpi.send(a[numsent], source, tag=numsent)
            numsent += 1
        else:
            # Signal end of processing with an OVERTAG tag.
            mpi.send(0, source, tag=OVERTAG)

    print "time=",mpi.wtime() - t0
    print "gotFrom=",gotFrom  
    print "a=\n", a
    print "b=\n", b
    print "a*b=\n", res


def slave(masterId, slaveId):

    # Initialize matrix 'b' and row vector 'r'.
    b = Numeric.zeros((rows, cols), 'f')
    r = Numeric.zeros(cols, 'f')
    prod = Numeric.zeros(cols, 'f')

    # Receive value of 'b' from master.
    b = mpi.bcast(b, masterId)

    while True:
        # Receive row from master.
        r, status = mpi.recv(masterId, tag=mpi.MPI_ANY_TAG,
                             retStatus=True)
        rowNum = status.tag
        source = status.source

        if rowNum == OVERTAG:
            break

        # Compute vector product.
        for i in range(cols):
            dot = 0.0
            for j in range(rows):
                dot += r[j] * b[j,i]
            prod[i] = dot

        # Send products to master. Tag identifies the row number.
        mpi.send(prod, masterId, tag=rowNum)
    
        
mpi.init()
myid =    mpi.comm_rank()
numproc = mpi.comm_size()
node =    mpi.get_processor_name()
root = 0

print "P%d of %d running on node %s" %(myid, numproc, node)
mpi.barrier()

if myid == root:
    master(myid)
else:
    slave(root, myid)

mpi.finalize()
