#!/usr/bin/env python

import sys
from Numeric import *

from mpy import *

MPY_Init()
rank = MPY_Comm_rank()
size = MPY_Comm_size()

root = 0

print "I am P%d of %d on node %s" % \
      (rank, size, MPY_Get_processor_name())
MPY_Barrier()

if rank == root:
    # Initialize a Numeric array.
    arr = identity(6, 'i')
    for i in range(6):
        for j in range(6):
            arr[i,j] = i*10+j

    # Note that in all the following MPY_Send() calls, parameter 'arrInfo' is set
    # to true. This allows the matching MPY_Recv() call to allocate a proper array
    # to receive the results.

    # Send the Numeric array to process 1, as a numeric array.
    MPY_Send(arr, 1, dataType=MPY_PYTHON_ARRAY, arrInfo=True)
    print "P%d sent to P1\n%s" % (rank, arr)
        
    # Send slices.
    # Send columns 1 and 2 of 'arr'.
    s = arr[:,1:3]
    MPY_Send(s, 1, dataType=MPY_PYTHON_ARRAY, arrInfo=True)
    print "P%d sent to P1\n%s" % (rank, s)

    # Send a 2x2 array, composed of the elements of row 3 and 4, in columns 3 and 4.
    s = arr[3:5,3:5]
    MPY_Send(s, 1, dataType=MPY_PYTHON_ARRAY, arrInfo=True)
    print "P%d sent to P1\n%s" % (rank, s)

elif rank == 1:

    # Note that all the following MPY_Recv() calls set parameter 'arrInfo' to true.
    # This is mandatory, because the matching MPY_Send() calls also set this
    # parameter. Consequently, MPY_Recv() will use the contents
    # of the private message sent by MPY_Send) to allocate an array whose
    # shape and type match that the of the array sent by MPY_Send().
    
    # Receive integer array. 
    obj2 = MPY_Recv(root, dataType=MPY_PYTHON_ARRAY, arrInfo=True)
    print "P%d recv\n%s" % (rank, obj2)
        
    # Receive slices.
    obj3 = MPY_Recv(root, dataType=MPY_PYTHON_ARRAY, arrInfo=True)
    print "P%d recv\n%s" % (rank, obj3)
    
    obj4 = MPY_Recv(root, dataType=MPY_PYTHON_ARRAY, arrInfo=True)
    print "P%d recv\n%s" % (rank, obj4)
