#!/usr/bin/env python

import sys
import Numeric

from mpy import *

MPY_Init()
rank = MPY_Comm_rank()
size = MPY_Comm_size()
root = 0

print "I am P%d of %d on node %s" % \
      (rank, size, MPY_Get_processor_name())

MPY_Barrier()

# All processes start with this 6x3 integer array.
arr = Numeric.array(((1,2,3),
                     (4,5,6),
                     (7,8,9),
                     (10,11,12),
                     (13,14,15),
                     (16,17,18)), 'i')

# Each process is responsible of updating a subset of the rows of array 'arr'.
# Note that, since the array will be reassembled by gathering messages
# in process rank order, it is important that the rows be allocated in
# rank order too.
# 
# The following code simulates the action of each process.
# Each one stres inside array 's' the set of rows it modified.
if rank == 0:          # rank 0 updates row 0
    s = arr[0]
    s[:] = (-1,-2,-3)
elif rank == 1:        # rank 1 updates rows 1-2
    s = arr[1:3]
    s[:] = ((-4,-5,-6),
            (-7,-8,-9))
elif rank == 2:        # rank 2 leaves row 3 intact
    s = arr[3:4]
else:
    s = arr[4:]        # rank 3 updates rows 4 and 5
    s[:] = ((200,201,202),
            (-300,-301,-302))

# Reassemble array after the modifications by each process.
# Reuse the original array as the output array.
res1 = MPY_Allgatherv(s, dataType=MPY_PYTHON_ARRAY, array=arr)
print "P%d res1=\n%s" % (rank, res1)

# Repeat the gather, this time letting the function allocate the output array
# for us. The allocated array will be one-dimensional. We thus reshape the array
# upon return.
res2 = MPY_Allgatherv(s, dataType=MPY_PYTHON_ARRAY)
res2 = Numeric.reshape(res2, (6,3))
print "P%d res2=\n%s" % (rank, res2)

MPY_Finalize()
