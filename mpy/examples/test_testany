#!/usr/bin/env python

import sys
import mpi
import Numeric
import time

mpi.init()
rank = mpi.comm_rank()
size = mpi.comm_size()

root = 0

print "I am P%d of %d on node %s" % \
      (rank, size, mpi.get_processor_name())
mpi.barrier()


if rank == 0:
    requests = []
    requests.append(mpi.isend('message #1 for process 3', 3))
    requests.append(mpi.isend('message #2 for process 3 bla bla bla', 3))
    requests.append(mpi.isend([i for i in range(1000,1010)], 3))
    print "P%d : isend called 3 times" % rank
    while True:
        idx = mpi.waitany(requests)
        if idx is None:
            break
        print "P%d request#%d completed" % (rank, idx)

elif rank == 3:
    requests = []
    requests.append(mpi.irecv(0))
    requests.append(mpi.irecv(0))
    requests.append(mpi.irecv(0))
    print "P%d irecv called 3 times" % rank

    n = 0
    while True:
        #idx, status = mpi.waitany(requests, retStatus=True)
        #if idx is None:
        #    break
        # By sleeping a little before the call to testany(),
        # we give the next message time to arrive, and run the
        # chance of never looping. This is just for example.
        # Of course, it is much more appropriate to simply
        # let MPI do the waiting for us by calling waitany().
        time.sleep(0.2)
        flag, idx, status = mpi.testany(requests, retStatus=True)
        n += 1
        if not flag:
            continue
        if idx is None:
            break
        print "P%d request #%d completed" % (rank, idx)
        obj = mpi.requestExtract(requests[idx])
        print "P%d obj=" % rank, obj, "status=",status
    print "P%d testany called %d times" % (rank, n)
        
